module Spec
  module Rails
    module Runner
      module ControllerInstanceMethods #:nodoc:

        # === render(options = nil, deprecated_status = nil, &block)
        #
        # This gets added to the controller's singleton meta class,
        # allowing Controller Specs to run in two modes, freely switching
        # from context to context.
        def render(options=nil, deprecated_status=nil, &block)
          unless block_given?
            unless integrate_views?
              @template.stub!(:file_exists?).and_return(true)
              @template.should_receive(:render_template).any_number_of_times.and_return(true) { |*args|
                @first_render ||= args[2]
              }
              @template.stub!(:find_template_extension_for).and_return("rhtml")
              @template.stub!(:read_template_file).and_return("this is fake content generated by rspec")
            end
          end
          response.controller_path = controller_path
          
          # The next two lines should be_gone('after 0.9')
          render_matcher.set_actual(ensure_default_options(options), response, &block)
          response.render_matcher = render_matcher
          
          super unless performed?
        end
      
        def response(&block)
          #NOTE - we're setting @update for the assert_select_spec - kinda weird, huh?
          # Should be_gone('after 0.9')
          @update = block
          @_response || @response
        end
      
        # Deprecated - gone for 9.0
        # Use response.should render_template or response.should have_text #see Spec::Rails::Matchers
        def should_render(expected)
          if expected.is_a?(Symbol) || expected.is_a?(String)
            expected = {:template => "#{controller_path}/#{expected}"}
          end
          render_matcher.set_expected(expected)
        end
      
        #backwards compatibility to RSpec 0.7.0-0.7.2
        # Deprecated - gone for 9.0
        # Use response.should render_template or response.should have_text #see Spec::Rails::Matchers
        alias_method :should_have_rendered, :should_render

        # Deprecated - gone for 9.0
        # Use response.should be_rjs #see Spec::Rails::Matchers
        def should_render_rjs(element, *opts)
          render_matcher.should_render_rjs(element, *opts)
        end

        # Deprecated - gone for 9.0
        # Use response.should_not be_rjs #see Spec::Rails::Matchers
        def should_not_render_rjs(element, *opts)
          render_matcher.should_not_render_rjs(element, *opts)
        end
      
        # Deprecated - gone for 9.0
        # Use response.should redirect_to #see Spec::Rails::Matchers
        def should_redirect_to(opts)
          redirect_matcher.set_expected(opts)
        end
      
        def redirect_to(opts)
          super
          redirect_matcher.match(request, opts) if redirect_matcher.interested_in?(opts)
        end

        def integrate_views!
          @integrate_views = true
        end

      private

        def integrate_views?
          @integrate_views
        end
      
        def render_called
          @render_called = true
        end

        def render_called?
          @render_called
        end

        def render_matcher
          @render_matcher ||= Spec::Rails::Expectations::RenderMatcher.new(controller_path, integrate_views?)
        end

        def redirect_matcher
          @redirect_matcher ||= Spec::Rails::Expectations::RedirectMatcher.new
        end
      
        def ensure_default_options(options)
          options ||= {:template => default_template_name}
          return options
        end
      end
    
      # The methods provided by Spec::Rails::Runner::ControllerEvalContext
      # are available to you in Controller Specs.
      #
      # The Public Class Methods are to be used within the +context+ block:
      #
      #   context "ThingController" do
      #     # public class methods go here
      #
      # The Public Instance Methods are to be used within the +specify+ block:
      #
      #   context "ThingController" do
      #     specify "should do stuff" do
      #       # public instance methods go here
      #
      # See Spec::Rails::Runner::ControllerContext for more general information
      # on Controller Specs
      class ControllerEvalContext < Spec::Rails::Runner::FunctionalEvalContext
        attr_reader :response, :request, :controller
      
        def setup_extra #:nodoc:
          unless @controller.class.ancestors.include?(ActionController::Base)
            Spec::Expectations.fail_with <<-EOE
  You have to declare the controller name in controller specs. For example:
    context "The ExampleController" do
      controller_name "example" #invokes the ExampleController
    end
  EOE
          end
          (class << @controller; self; end).class_eval do
            # Rails 1.1.6 doesn't have controller_path, but >= 1.2.0 does
            unless instance_methods.include?("controller_path")
              def controller_path #:nodoc:
                self.class.name.underscore.gsub('_controller','')
              end
            end
            include ControllerInstanceMethods
          end
          @controller.integrate_views! if @integrate_views
          begin
            @controller.session = session
          rescue
          end
        end

        class << self
          attr_accessor :controller_class_name # :nodoc:
          
          # You MUST provide a controller_name within the context of
          # your controller specs:
          #
          #   context "ThingController" do
          #     controller_name :thing
          #     ...
          def controller_name(name=nil)
            @controller_class_name = "#{name}_controller".camelize
          end
          
          # Use this to instruct RSpec to render views in your controller specs (Integration Mode).
          # 
          #   context "ThingController" do
          #     integrate_views
          #     ...
          #
          # See Spec::Rails::Runner::ControllerContext for more information about
          # Integration and Isolation modes.
          def integrate_views
            @integrate_views = true
          end
          def integrate_views? # :nodoc:
            @integrate_views
          end
        end

        def setup #:nodoc:
          super

          @controller_class.send(:define_method, :rescue_action) { |e| raise e }

          @deliveries = []
          ActionMailer::Base.deliveries = @deliveries
        end

        # Uses ActionController::Routing::Routes to generate
        # the correct route for a given set of options.
        # == Examples
        #   route_for(:controller => 'registrations', :action => 'edit', :id => 1)
        #     => '/registrations/1;edit'
        def route_for(options)
          ensure_that_routes_are_loaded
          routes = ActionController::Routing::Routes.generate(options)
          # Rails 1.1.6
          return routes[0] if routes.is_a?(Array)
          # Rails 1.2
          return routes if routes.is_a?(String)
        end
      
        #backwards compatibility to RSpec 0.7.0-0.7.3
        alias_method :routing, :route_for
      
        private
          def ensure_that_routes_are_loaded
            ActionController::Routing::Routes.reload if ActionController::Routing::Routes.empty?
          end
      end

      # Controller Specs live in $RAILS_ROOT/spec/controllers/.
      #
      # Controller Specs use Spec::Rails::Runner::ControllerContext, which supports running specs for
      # Controllers in two modes, which represent the tension between the more granular
      # testing common in TDD and the more high level testing built into
      # rails. BDD sits somewhere in between: we want to a balance between
      # specs that are close enough to the code to enable quick fault
      # isolation and far enough away from the code to enable refactoring
      # with minimal changes to the existing specs.
      #
      # == Isolation mode (default)
      #
      # No dependencies on views because none are ever rendered. The
      # benefit of this mode is that can spec the controller completely
      # independent of the view, allowing that responsibility to be
      # handled later, or by somebody else. Combined w/ separate view
      # specs, this also provides better fault isolation.
      #
      # == Integration mode
      #
      # To run in this mode, include the +integrate_views+ declaration
      # in your controller context:
      # 
      #   context "ThingController" do
      #     integrate_views
      #     ...
      # 
      # In this mode, controller specs are run in the same way that
      # rails functional tests run - one set of tests for both the
      # controllers and the views. The benefit of this approach is that
      # you get wider coverage from each spec. Experienced rails
      # developers may find this an easier approach to begin with, however
      # we encourage you to explore using the isolation mode and revel
      # in its benefits.
      #
      # See Spec::Rails::Runner::ControllerEvalContext for information
      # about methods you can use in your Controller Specs
      class ControllerContext < Spec::Rails::Runner::Context

        def execution_context(specification=nil) # :nodoc:
          instance = execution_context_class.new(specification)
          controller_class_name = @context_eval_module.controller_class_name
          integrate_views = @context_eval_module.integrate_views? ? true : false
          instance.instance_eval {
            @controller_class_name = controller_class_name.to_s
            @integrate_views = integrate_views
          }
          instance
        end

        def before_context_eval # :nodoc:
          inherit_context_eval_module_from Spec::Rails::Runner::ControllerEvalContext
          @context_eval_module.init_global_fixtures
        end

      end
    end
  end
end